---
title: "wyz.code.offensiveProgramming"
author: "Fabien GELINEAU"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{wyz.code.offensiveProgramming}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style>
body {
text-align: justify}
</style>

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r, eval = TRUE, echo = FALSE}
pkn <- 'wyz.code.offensiveProgramming'
```


Package **`r pkn`**  aims to provide a strict type checking inforcement in **R**.

**R** is a weakly typed script language. As such, it simplifies greatly program writing and allows for great flexibility. 
That's fine, and conceptually, there is no issue about that. 

Indeed, sometimes you need to produce code that has to rely on strongly typed checking. How is this traditionnaly achieved using **R**? 

Mainly, by 2 means, either conventions, or defensive programming. 

Conventions are generally stated and shared through the documentation of function parameters and through the provided code examples. Notice, that quality and consistency of this changes a lot from a package to another. 

Second, defensive programming, id est, implementation of controls in the code to ensure the parameters complies to expectations. Again, depth and quality of controls vary greatly from one package to another. 

The main objective of package **`r pkn`** is to allow strict type checking in R, without the burden of instrumenting all the defensive coding tactics. 

# Dynamic type checking {.tabset .tabset-fade .tabset-pills}

## How does this work ? 

Imagine you have a class **Addition**, and you would like to be able to use it, 

i. in a standard R way, as it might already been used as such by several people in many programs,
i. in a more controled way, enforcing type checking

To achieve this, you will have to 

1. instrument a little bit the code of the class,
1. use this instrumentation to enforce dynamic type checking 


### Code instrumentation 

To instrument the code, you must first ensure, that your class is either an **environment** or an **R6** class. Code instrumentation won't work with **S4** and **RC** classes. 

Instrumenting class code means that you have to 

1. provide a declaration allowing to know the return type of each function in the class
1. turn dumb standard **R** parameter names into semantic parameter names to allow type checking inference


Instrumenting class code can be achieved in two main ways

1. by adding extraneous code to the class definition. Let's call this approach **_the dormant way_**,
1. by dynamically adding required attributes definitions to a class instance. Let's call this approach **_the transcient way_**. 

### Use instrumented class

Here you'll just have to call a given function to execute the code, enforcing type checking for 

1. each argument
1. the returned result


Type checking means here

1. check each parameter values for type concordance
1. check each parameter values for number of values concordance with the specification you provided
1. 

Instrumenting class code means that you must provide

1. a declaration allowing to know the return type of each function in the class
1. complete parameter names to match some semantic and to allow inference of type checking



## BLA BL

Currently, developper builds the code, the documentation, the tests, and resolves issues and conflicts about the functional behavior and the R packaging requirement system. 

Some tools allow to reduce the burden as package **<code>roxygen2</code>** to automate partialy manual pages production, and as package **<code>testthat</code>** for unit tests production and run. This alleviates the pain, but the burden remains too heavy. 

Package **<code>rspirit</code>** tries to reduce further this burden. The proposal is the following

1. Focus on code
2. Change the way to produce manual pages
3. Produce functional tests instead of unit tests
4. Allow immediate reuse of your tests
5. Build package from the produced results

## Where and when to use **<code>rspirit</code>**

Package **<code>rspirit</code>** works with S3 and R6 classes currently. So, anytime you have to create one or the other, you should use package **<code>rspirit</code>** to accelerate your production and to allow greater discovery and reuse of your work. 

As S4, and RC classes are not supported, using package **<code>rspirit</code>** won't bring any result, and might even complexify your task. With S4 and RC, simply avoid using **<code>rspirit</code>**.

You wonder if you could mix some classes using **<code>rspirit</code>**, and some other not using it. Of course, yes. You should use it whenever you want your functional test cases, to be reused and to stay alive. With **<code>rspirit</code>**, your functional test case R code, will be reused often.  

Should you enforce usage of **<code>rspirit</code>** on existing R packages? That's a really complicated question. I would suggest to examine it case by case. For general cases, use following rule of thumb: use **<code>rspirit</code>** for new packages and for new package releases. 


## Focus on code

Code is the key. This is what brings the value to your package. Focus on it. Spend time on it. Polish it.

Package **<code>rspirit</code>** will help you being more productive in code production. It brings following features 

1. a tidy approach to create and record your functional tests cases
1. an industrial relationship between your functional tests cases and your unit test cases
1. a non-intrusive assistant to help you during R function creation
1. an on-demand invokable code verifyer XXX
